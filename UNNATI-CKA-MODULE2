#!/usr/bin/env bash
###############################################################################
# cka_module2_grader.sh – CKA MODULE-2 autograder with GitHub report upload
# Author: Abhay Dandge 
###############################################################################
#set -euo pipefail

# To debuge script uncomment below line
# set -x

# === GITHUB AUTHENTICATION DETAILS ===

GITHUB_USERNAME="unnati-git"  
GITHUB_TOKEN="********************************"


########################  COLOUR HELPERS  #####################################
BOLD='\e[1m'; RED='\e[1;31m'; GREEN='\e[1;32m'; YELLOW='\e[1;33m'; BLUE='\e[1;34m'; RESET='\e[0m'
ok()   { printf "${GREEN}✔ %s${RESET}\n" "$*"; }
err()  { printf "${RED}✘ %s${RESET}\n" "$*"; }
info() { printf "${YELLOW}%s${RESET}\n" "$*"; }

echo -e "${GREEN}Enter your name ? ${RESET}"
read STUDENT_NAME
echo -e "${GREEN}Enter your batch name ? (eg: Kucl 2.3) ${RESET}"
read COURSE_NAME
#read -rp "Enter task name: " TASK_NAME
#read -rp "Enter task number: " TASK_NO
MODULE_NAME="CKA-MODULE_2"
banner(){
  local n="$1"
  echo -e "\n${BLUE}===================================================================${RESET}"
  echo -e "${GREEN} Exclusive task for Unnati Student${RESET} ${RED}http://unnatidevelopment.in/${RESET}"
  echo -e "${YELLOW}             Grading CKA-MODULE_2 Task${n}${RESET}"
  echo -e "${BLUE}===================================================================${RESET}"
}

########################  EXPECTED RESOURCE NAMES  ############################
SECRET_NAME=db-credentials; SECRET_USER=admin;     SECRET_PASS=redhat123
CONFIGMAP_NAME=app-config
ANNOT_POD=custom-pod
NP_SERVICE=np-service
TAINT_KEY=team; TAINT_VAL=dev; TAINT_EFFECT=NoSchedule; TAINT_POD=dev-app
PV_NAME=local-pv; PVC_NAME=myclaim
HOSTPATH_POD=host-logger
EMPTYDIR_POD=logger-pod
FULLSTACK_POD=full-stack-app


########################  HELPER FUNCTIONS  ###################################
has_secret_key(){ 
  [[ "$(kubectl get secret "$1" -o jsonpath="{.data.$2}" | base64 -d 2>/dev/null)" == "$3" ]] 
}

########################  TASK FUNCTIONS  #####################################
task1(){  # Secrets
  banner 1
  # 1) secret exists
  if kubectl get secret "$SECRET_NAME" &>/dev/null; then
    ok "Secret exists"
  else
    err "Secret missing"
    return 1
  fi

  # 2) correct username
  if has_secret_key "$SECRET_NAME" username "$SECRET_USER"; then
    ok "username key correct"
  else
    err "username mismatch"
    return 1
  fi

  # 3) correct password
  if has_secret_key "$SECRET_NAME" password "$SECRET_PASS"; then
    ok "password key correct"
  else
    err "password mismatch"
    return 1
  fi

  # 4) at least one pod consumes via envFrom
  if kubectl get pods -o json \
       | jq -e --arg s "$SECRET_NAME" \
           '.items[] | select(.spec.containers[]?.envFrom[]?.secretRef?.name==$s)' \
       &>/dev/null; then
    ok "Pod consumes secret via envFrom"
  else
    err "No pod consumes secret"
    return 1
  fi
}



task2(){ # ConfigMap
  banner 2
  kubectl get configmap "$CONFIGMAP_NAME" -o yaml 2>/dev/null \
    | grep -q 'APP_MODE: production' \
    && ok "ConfigMap with APP_MODE=production present" \
    || { err "ConfigMap missing or incorrect"; return 1; }
}

task3(){ # Annotations
  banner 3
  kubectl get pod "$ANNOT_POD" -o json 2>/dev/null \
    | jq -e '.metadata.annotations.purpose=="test"' &>/dev/null \
    && ok "Pod annotated with purpose=test" \
    || { err "Annotation missing"; return 1; }
}

task4(){ # NodePort Service
  banner 4
  [[ "$(kubectl get svc "$NP_SERVICE" -o jsonpath='{.spec.type}' 2>/dev/null)" == "NodePort" ]] \
    && ok "NodePort service present" \
    || { err "Service missing or wrong type"; return 1; }
}

task5(){  # Taints & Tolerations
  banner 5
  local ret=0

  if kubectl get nodes -o json \
       | jq -e --arg k "$TAINT_KEY" --arg v "$TAINT_VAL" --arg e "$TAINT_EFFECT" \
           '.items[] | select(.spec.taints[]? | .key==$k and .value==$v and .effect==$e)' \
       &>/dev/null; then
    ok "Node tainted"
  else
    err "Taint not found"
    ret=1
  fi

  if kubectl get pod "$TAINT_POD" -o json 2>/dev/null \
       | jq -e --arg k "$TAINT_KEY" --arg v "$TAINT_VAL" --arg e "$TAINT_EFFECT" \
           '.spec.tolerations[]? | select(.key==$k and .value==$v and .effect==$e)' \
       &>/dev/null; then
    ok "Pod tolerates taint"
  else
    err "Pod toleration missing"
    ret=1
  fi

  return $ret
}


task6(){ # PV & PVC
  banner 6
  [[ "$(kubectl get pvc "$PVC_NAME" -o jsonpath='{.status.phase}' 2>/dev/null)" == "Bound" ]] \
    && ok "PVC is Bound" \
    || { err "PVC not bound"; return 1; }
}

task7(){ # hostPath volume
  banner 7
  kubectl get pod "$HOSTPATH_POD" -o json 2>/dev/null | jq -e \
    '.spec.volumes[]? | select(.hostPath?.path=="/var/log")' \
    &>/dev/null && ok "hostPath /var/log mounted" || { err "hostPath mount missing"; return 1; }
}

task8(){ # emptyDir volume
  banner 8
  kubectl get pod "$EMPTYDIR_POD" -o json 2>/dev/null \
    | jq -e '.spec.volumes[]?.emptyDir != null' &>/dev/null \
    && ok "emptyDir volume present" \
    || { err "emptyDir volume missing"; return 1; }
}

task9(){ # full-stack label
  banner 9
  kubectl get pod "$FULLSTACK_POD" -o json 2>/dev/null \
    | jq -e '.metadata.labels.app=="web"' &>/dev/null \
    && ok "Pod full-stack-app with label app=web present" \
    || { err "Pod or label missing"; return 1; }
}

########################  REPORT & GITHUB PUSH  ################################

########################  CLI PARSING  #########################################
usage(){
  cat <<EOF
Usage: $0 [taskN|all|help] [--student NAME]

Examples:
  $0 task3 --student abhay     # grade only Task 3
  $0 all     --student abhay   # grade everything & push report
EOF
}

[[ ${1:-} == help ]] && { usage; exit 0; }

ACTION="all"
STUDENT="unknown"

while [[ $# -gt 0 ]]; do
  case "$1" in
    task[1-9]|all)   ACTION="$1"; shift ;;
    --student=*)     STUDENT="${1#--student=}"; shift ;;
    --student)       STUDENT="$2"; shift 2 ;;
    *)               echo -e "${RED}✘ Unknown argument '$1'${RESET}"; usage; exit 1 ;;
  esac
done

TASK_NO="$ACTION"  # Extract task number from ACTION

set +e
# === RUN TASK GRADING ===
# === RUN TASK GRADING ===
echo -e "${CYAN}🔍 Starting Task Grading...${RESET}"
PASSED=0
FAILED=0

if [[ "$TASK_NO" == "all" ]]; then
  for i in {1..9}; do
    echo -e "${YELLOW}→ Running Task $i...${RESET}"
    if "task$i"; then
      echo -e "${GREEN}✔ Task $i Passed${RESET}"
      ((PASSED++))
    else
      echo -e "${RED}✘ Task $i Failed${RESET}"
      ((FAILED++))
    fi
    echo ""
  done
else
  if declare -f "$TASK_NO" >/dev/null; then
    echo -e "${YELLOW}→ Running $TASK_NO...${RESET}"
    if "$TASK_NO"; then
      echo -e "${GREEN}✔ $TASK_NO Passed${RESET}"
      ((PASSED++))
    else
      echo -e "${RED}✘ $TASK_NO Failed${RESET}"
      ((FAILED++))
    fi
  else
    echo -e "${RED}✘ Unknown task function: $TASK_NO${RESET}"
    exit 1
  fi
fi

# === RESULT ===
if [[ "$FAILED" -eq 0 ]]; then
  RESULT="Passed"
else
  RESULT="Failed"
fi
# === SUMMARY ===

echo -e "${CYAN}🧾 Summary:${RESET} ${GREEN}$PASSED Passed${RESET}, ${RED}$FAILED Failed${RESET}"


#set -e  # Re-enable strict mode

# === CONFIRMATION LOOP ===
while true; do
  read -e -rp "Do you want to run the task submission? (yes/no):" RUN_SCRIPT
  case "$RUN_SCRIPT" in
    [Yy][Ee][Ss])
      echo -e "✅ ${GREEN}Proceeding with task submission... ${RESET}"
      break
      ;;
    [Nn][Oo])
      echo -e "${RED}❌ Exiting without running the script.${RESET}"
      exit 0
      ;;
    *)
      echo -e "⚠️${RED} Please answer yes or no.${RESET}"
      ;;
  esac
done


# === HELPER FUNCTIONS ===
function check_or_install_git() {
  if ! command -v git &> /dev/null; then
    echo "${GREEN}[+] Installing git..."
    sudo apt update &>/dev/null
    sudo apt install git -y &>/dev/null 
  else
    echo -e "${GREEN}[+] Git is already installed.${RESET}"
  fi
}

function check_or_install_gh() {
  if ! command -v gh &> /dev/null; then
    echo "[+] Installing GitHub CLI (gh)..."
    sudo apt update &>/dev/null 
    sudo apt install gh -y &>/dev/null
  else
    echo -e "${GREEN}[+] GitHub CLI (gh) is already installed.${RESET}"
  fi
}

function check_git_config() {
  GIT_USER_NAME=$(git config --global user.name)
  GIT_USER_EMAIL=$(git config --global user.email)

  if [ -z "$GIT_USER_NAME" ]; then
    git config --global user.name "$GITHUB_USERNAME"
  fi

  if [ -z "$GIT_USER_EMAIL" ]; then
    git config --global user.email "${GITHUB_USERNAME}@users.noreply.github.com"
  fi
}

function check_gh_auth() {
  echo -e "${GREEN}[+] Authenticating GitHub CLI for user $STUDENT_NAME...${RESET}"

  echo "$GITHUB_TOKEN" | gh auth login --with-token &>/dev/null

  if [ $? -eq 0 ]; then
    echo -e "${GREEN}[+] GitHub CLI authenticated successfully!${RESET}"
  else
    echo "${RED}❌ GitHub authentication failed. Please check your token.${RESET}"
    exit 1
  fi
}

# === INITIAL SETUP ===
check_or_install_git
check_or_install_gh
check_git_config
check_gh_auth

# === CONFIGURATION ===
MAIN_REPO="abhay-dandge/task-submission-records"
CSV_FILE="task_status.csv"
CLONE_DIR="student-task-repo"
MODULE_NAME="CKA-MODULE_2"
# === INPUT VALIDATION ===
if [ -z "$STUDENT_NAME" ] || [ -z "$COURSE_NAME" ] || [ -z "$TASK_NO" ]; then
  echo "❌ All inputs are required. Exiting."
  exit 1
fi

# === CLONE OR REUSE DIRECTORY ===
if [ ! -d "$CLONE_DIR" ]; then
  gh repo fork "$MAIN_REPO" --clone "$CLONE_DIR" --remote &>/dev/null
else
  echo -e "${GREEN}[+] Clone directory already exists: $CLONE_DIR${RESET}"
fi

cd "$CLONE_DIR" || exit

# === CONFIGURE REMOTES ===
git remote set-url origin "https://${GITHUB_USERNAME}:${GITHUB_TOKEN}@github.com/${GITHUB_USERNAME}/task-submission-records.git" >/dev/null 2>&1
if ! git remote | grep -q upstream; then
  git remote add upstream "https://github.com/${MAIN_REPO}.git" >/dev/null 2>&1
fi

# === SYNC WITH UPSTREAM ===
git fetch upstream >/dev/null 2>&1
git checkout main >/dev/null 2>&1
git reset --hard upstream/main >/dev/null 2>&1
git push origin main --force >/dev/null 2>&1

# === CREATE BRANCH ===
BRANCH="task-${TASK_NO}-${STUDENT_NAME// /-}"
git checkout -b "$BRANCH" >/dev/null 2>&1

# === APPEND TO CSV ===
if [ ! -f "$CSV_FILE" ]; then
  echo "Task No,Task Name,Student Name,Date Time,Status,Course Name,Module Name" > "$CSV_FILE"
fi

DATE_TIME=$(date "+%Y-%m-%d %H:%M:%S")
TASK_STATUS=$RESULT
echo "$TASK_NO,$STUDENT_NAME,$DATE_TIME,$TASK_STATUS,$COURSE_NAME,$MODULE_NAME" >> "$CSV_FILE"

# === COMMIT & PUSH ===
git add "$CSV_FILE" >/dev/null 2>&1
git commit -m "Task $TASK_NO completed by $STUDENT_NAME on $DATE_TIME" >/dev/null 2>&1
git push -u origin "$BRANCH" >/dev/null 2>&1

# === CREATE PR IF NEEDED ===
if git log origin/main..HEAD | grep .; then
  gh pr create \
    --title "Task $TASK_NO Completed by $STUDENT_NAME" \
    --body "Auto-submitted task from student script." \
    --base main \
    --head "${GITHUB_USERNAME}:${BRANCH}" \
    --repo "$MAIN_REPO"  >/dev/null 2>&1

  if [ $? -eq 0 ]; then
    echo -e "\n✅${GREEN} Pull Request created successfully!${RESET}"
  else
    echo -e "\n❌${RED} Pull Request creation failed | Already done task ??.${RESET}"
  fi
else
  echo -e "\n⚠ ${RED} No changes detected between main and your branch. PR not created.${RESET}"
fi

# === DONE ===
echo -e "\n🎉 ${GREEN} Task submission complete! Well done, $STUDENT_NAME! ${RESET}"

################## LOGOUT AND CLEANUP ##################
gh auth logout -h github.com  &>/dev/null
git config --global --unset credential.helper  &>/dev/null
